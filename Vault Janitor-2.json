{
  "name": "Vault Janitor",
  "nodes": [
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "qwen2.5:14b-instruct",
          "mode": "list",
          "cachedResultName": "qwen2.5:14b-instruct"
        },
        "messages": {
          "values": [
            {
              "content": "={{ $json.prompt }}"
            }
          ]
        },
        "options": {
          "temperature": 0
        }
      },
      "type": "@n8n/n8n-nodes-langchain.ollama",
      "typeVersion": 1,
      "position": [
        -9344,
        -1168
      ],
      "id": "154f2b42-ef9b-4bee-8e94-2d7d14eab15f",
      "name": "Message a model",
      "credentials": {
        "ollamaApi": {
          "id": "UrA6yVTCmM5YHOen",
          "name": "Ollama account"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { success: true, message: 'Vault janitor completed', log_path: $json.log_path, stats: $json.stats } }}",
        "options": {}
      },
      "id": "4c19fd25-7450-4eb4-8757-e0073c8a0762",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        -6848,
        -1248
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "=http://100.111.39.118:27123/vault/{{ encodeURIComponent($json.log_path.replace('/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1/', '')) }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "content",
              "value": "={{ $json.log_content }}"
            }
          ]
        },
        "options": {}
      },
      "id": "a3cddc8c-de86-4b1c-8972-6aae6bbdf711",
      "name": "Write Log File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -7040,
        -1168
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "GLdl8kauGGZ3sdXZ",
          "name": "Header Auth account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "try {\n  const items = $input.all();\n  const timestamp = new Date().toISOString();\n  const date = timestamp.split('T')[0];\n  \n  // Filter out skipped items\n  const processedItems = items.filter(i => !i.json.skip);\n  \n  const stats = {\n    total: processedItems.length,\n    updated: processedItems.filter(i => i.json.needs_update && !i.json.error).length,\n    moved: processedItems.filter(i => i.json.needs_move && !i.json.error).length,\n    needs_review: processedItems.filter(i => i.json.analysis?.needs_manual_review || i.json.error).length,\n    errors: processedItems.filter(i => i.json.error).length\n  };\n  \n  const reviewFiles = processedItems\n    .filter(i => i.json.analysis?.needs_manual_review || i.json.error)\n    .map(i => ({\n      filename: i.json.filename,\n      confidence: i.json.analysis?.confidence || 'unknown',\n      error: i.json.error\n    }));\n  \n  const movedFiles = processedItems\n    .filter(i => i.json.needs_move && !i.json.error)\n    .map(i => ({\n      filename: i.json.filename,\n      from: i.json.current_folder,\n      to: i.json.analysis?.correct_folder || 'unknown'\n    }));\n  \n  const errorFiles = processedItems\n    .filter(i => i.json.error)\n    .map(i => ({\n      filename: i.json.filename,\n      error: i.json.error\n    }));\n  \n  let log = `# Vault Janitor Log - ${timestamp}\\n\\n## Summary\\n`;\n  log += `- **Total files processed:** ${stats.total}\\n`;\n  log += `- **Metadata updated:** ${stats.updated}\\n`;\n  log += `- **Files moved:** ${stats.moved}\\n`;\n  log += `- **Needs manual review:** ${stats.needs_review}\\n`;\n  if (stats.errors > 0) {\n    log += `- **Errors:** ${stats.errors}\\n`;\n  }\n  \n  log += `\\n## Files Needing Review\\n`;\n  if (reviewFiles.length > 0) {\n    reviewFiles.forEach(file => {\n      log += `- [[${file.filename}]] - ${file.confidence} confidence`;\n      if (file.error) {\n        log += ` (Error: ${file.error})`;\n      }\n      log += '\\n';\n    });\n  } else {\n    log += `None\\n`;\n  }\n  \n  log += `\\n## Files Moved\\n`;\n  if (movedFiles.length > 0) {\n    movedFiles.forEach(file => {\n      log += `- [[${file.filename}]] → ${file.to}\\n`;\n    });\n  } else {\n    log += `None\\n`;\n  }\n  \n  if (errorFiles.length > 0) {\n    log += `\\n## Errors\\n`;\n    errorFiles.forEach(file => {\n      log += `- [[${file.filename}]] - ${file.error}\\n`;\n    });\n  }\n  \n  return {\n    json: {\n      log_content: log,\n      log_path: `/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1/Work/00-Inbox/Janitor-Log-${date}.md`,\n      stats: stats\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      log_content: `# Vault Janitor Log - ${new Date().toISOString()}\\n\\nError generating log: ${error.message}\\n`,\n      log_path: `/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1/Work/00-Inbox/Janitor-Log-${new Date().toISOString().split('T')[0]}.md`,\n      stats: { total: 0, updated: 0, moved: 0, needs_review: 0, errors: 1 }\n    }\n  };\n}"
      },
      "id": "fd128479-5cbb-40fb-b4ac-f727c2f256eb",
      "name": "Build Summary Log",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7248,
        -1168
      ]
    },
    {
      "parameters": {},
      "id": "25bc5489-7b40-4ff6-b11a-2bda0b2a6ae2",
      "name": "Merge All Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [
        -7440,
        -1168
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "=http://100.111.39.118:27123/vault/{{ encodeURIComponent($json.relative_path || $json.filepath.replace('/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1/', '')) }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "content",
              "value": "={{ $json.updated_content }}"
            }
          ]
        },
        "options": {}
      },
      "id": "19a9ce31-de96-4e1b-8f74-b654d2cc1040",
      "name": "Write Review Tag",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -8240,
        -1072
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "GLdl8kauGGZ3sdXZ",
          "name": "Header Auth account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "try {\n  const data = $json;\n  const fm = data.frontmatter || {};\n  \n  // Build frontmatter with needs-manual-review status\n  const updated = {\n    ...fm,\n    date: fm.date || new Date().toISOString().split('T')[0],\n    type: 'meeting',\n    status: 'needs-manual-review'\n  };\n  \n  // Add or update tags\n  const existingTags = fm.tags || '';\n  const needsReviewTag = '#needs-manual-review';\n  let tags = existingTags;\n  if (!tags.includes(needsReviewTag)) {\n    tags = tags ? `${tags} ${needsReviewTag}` : needsReviewTag;\n  }\n  updated.tags = tags;\n  \n  // Build new frontmatter block\n  const fmLines = Object.entries(updated)\n    .map(([k, v]) => {\n      const value = typeof v === 'string' && v.includes(':') ? `\"${v}\"` : v;\n      return `${k}: ${value}`;\n    })\n    .join('\\n');\n  \n  const newFrontmatter = `---\\n${fmLines}\\n---`;\n  \n  // Replace old frontmatter or add if missing\n  let newContent = data.content || '';\n  if (newContent.match(/^---\\n[\\s\\S]*?\\n---/)) {\n    newContent = newContent.replace(/^---[\\s\\S]*?---/, newFrontmatter);\n  } else {\n    newContent = newFrontmatter + '\\n\\n' + newContent;\n  }\n  \n  return {\n    json: {\n      ...data,\n      updated_content: newContent\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...$json,\n      updated_content: $json.content || '',\n      error: error.message\n    }\n  };\n}"
      },
      "id": "e66a79be-d40a-4c59-aa9a-743b1a64e36a",
      "name": "Tag for Manual Review",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -8448,
        -1072
      ]
    },
    {
      "parameters": {
        "method": "DELETE",
        "url": "=http://100.111.39.118:27123/vault/{{ encodeURIComponent($json.old_relative_path) }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "id": "d4e1920e-9f8b-47f1-8376-ccda7f3dfb5f",
      "name": "Delete Old File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -7248,
        -1376
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "GLdl8kauGGZ3sdXZ",
          "name": "Header Auth account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "=http://100.111.39.118:27123/vault/{{ encodeURIComponent($json.new_relative_path) }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "content",
              "value": "={{ $json.move_content }}"
            }
          ]
        },
        "options": {}
      },
      "id": "d7011ca2-59b2-42d4-a89d-1daa844846aa",
      "name": "Write File to New Location",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -7440,
        -1376
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "GLdl8kauGGZ3sdXZ",
          "name": "Header Auth account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Prepare file move operation\n// The actual move will be done by writing to new location and deleting old\nconst data = $json;\nconst vaultRoot = '/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1';\nconst oldRelativePath = data.relative_path || data.filepath.replace(vaultRoot + '/', '');\nconst newFolder = data.analysis.correct_folder.replace(/\\/$/, '');\nconst newRelativePath = `${newFolder}/${data.filename}`;\n\nreturn {\n  json: {\n    ...data,\n    old_relative_path: oldRelativePath,\n    new_relative_path: newRelativePath,\n    move_content: data.updated_content || data.content\n  }\n};"
      },
      "id": "80c1d135-7e1f-48fa-ad44-bd6db93059fa",
      "name": "Prepare File Move",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7648,
        -1376
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Folders will be created automatically when files are written to them\n// This is a no-op node to maintain workflow structure\n// Process each item individually (runOnceForEachItem mode)\nreturn [{ json: $json }];"
      },
      "id": "1855bcf5-2be2-4b6e-bddb-5c60922808a7",
      "name": "Create Target Folder",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -7840,
        -1376
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "needs-move",
              "leftValue": "={{ $json.needs_move }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "0ec6d416-13b6-49cd-a91a-f71ac32b0859",
      "name": "Needs Move?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -8048,
        -1264
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "=http://100.111.39.118:27123/vault/{{ encodeURIComponent($json.relative_path || $json.filepath.replace('/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1/', '')) }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "content",
              "value": "={{ $json.updated_content }}"
            }
          ]
        },
        "options": {}
      },
      "id": "0bf3a47a-f3fc-4abc-881a-d69cdf84ce8f",
      "name": "Write Updated Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -8240,
        -1264
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "GLdl8kauGGZ3sdXZ",
          "name": "Header Auth account"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "try {\n  const data = $json;\n  const fm = data.frontmatter || {};\n  const analysis = data.analysis || {};\n  \n  // Build updated frontmatter\n  const updated = {\n    date: analysis.date_detected || fm.date || new Date().toISOString().split('T')[0],\n    type: 'meeting',\n    meeting_type: analysis.meeting_type || 'unknown',\n    person: analysis.person || '',\n    client: analysis.client || '',\n    location: analysis.location || '',\n    partner: analysis.partner || '',\n    team: analysis.team || '',\n    attendees: analysis.attendees || '',\n    summary: analysis.summary || '',\n    project: fm.project || 'unclassified',\n    status: 'processed'\n  };\n  \n  // Remove empty fields\n  Object.keys(updated).forEach(key => {\n    if (updated[key] === '') {\n      delete updated[key];\n    }\n  });\n  \n  // Build new frontmatter block\n  const fmLines = Object.entries(updated)\n    .map(([k, v]) => {\n      // Escape colons in values if needed\n      const value = typeof v === 'string' && v.includes(':') ? `\"${v}\"` : v;\n      return `${k}: ${value}`;\n    })\n    .join('\\n');\n  \n  const newFrontmatter = `---\\n${fmLines}\\n---`;\n  \n  // Replace old frontmatter in content or add if missing\n  let newContent = data.content || '';\n  if (newContent.match(/^---\\n[\\s\\S]*?\\n---/)) {\n    newContent = newContent.replace(/^---[\\s\\S]*?---/, newFrontmatter);\n  } else {\n    newContent = newFrontmatter + '\\n\\n' + newContent;\n  }\n  \n  // Add action items if not present\n  if (analysis.action_items && Array.isArray(analysis.action_items) && analysis.action_items.length > 0) {\n    if (!newContent.includes('## Action Items')) {\n      const items = analysis.action_items.map(item => `- [ ] ${item}`).join('\\n');\n      newContent += `\\n\\n## Action Items\\n${items}`;\n    }\n  }\n  \n  // Add key topics if not present\n  if (analysis.key_topics && Array.isArray(analysis.key_topics) && analysis.key_topics.length > 0) {\n    if (!newContent.includes('## Key Topics')) {\n      const topics = analysis.key_topics.map(t => `- ${t}`).join('\\n');\n      newContent += `\\n\\n## Key Topics\\n${topics}`;\n    }\n  }\n  \n  return {\n    json: {\n      ...data,\n      updated_content: newContent\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...$json,\n      updated_content: $json.content || '',\n      error: error.message\n    }\n  };\n}"
      },
      "id": "1600f50c-d5c5-4b0a-9f3b-5226bfb3ae63",
      "name": "Update Frontmatter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -8448,
        -1264
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "id": "needs-review-1",
              "leftValue": "={{ $json.analysis && $json.analysis.needs_manual_review }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            },
            {
              "id": "needs-review-2",
              "leftValue": "={{ $json.analysis && $json.analysis.confidence }}",
              "rightValue": "low",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "needs-review-3",
              "leftValue": "={{ $json.analysis && $json.analysis.error }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "id": "fb923eae-caf5-4626-b3fb-786d410513f5",
      "name": "Needs Manual Review?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -8640,
        -1168
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "try {\n  // Get original data from Build LLM Prompt node (preserved in input)\n  // The Set node preserves all input fields, so $input.item.json should have everything\n  // Extract LLM response first (it's in $json.content as a string)\n  let originalData = {};\n  \n  // Try to get original data from input - Set node preserves all fields\n  // In runOnceForEachItem mode, we can only use $input.item.json\n  if ($input && $input.item && $input.item.json) {\n    originalData = { ...$input.item.json };\n  } else if ($json && ($json.filepath || $json.relative_path || $json.frontmatter)) {\n    // Last resort: use $json but exclude LLM response fields\n    const { content, output, text, response, message, ...rest } = $json;\n    originalData = rest;\n  }\n  \n  // Handle Anthropic node response format\n  let llmOutput = '';\n  \n  // n8n Anthropic node typically returns: { output: \"...\" } or { text: \"...\" } or direct text\n  if ($json.output) {\n    llmOutput = $json.output;\n  } else if ($json.text) {\n    llmOutput = $json.text;\n  } else if ($json.content) {\n    // Handle array format: { content: [{ type: \"text\", text: \"...\" }] }\n    if (Array.isArray($json.content)) {\n      const textContent = $json.content.find(c => c.type === 'text');\n      if (textContent && textContent.text) {\n        llmOutput = textContent.text;\n      }\n    } else if (typeof $json.content === 'string') {\n      llmOutput = $json.content;\n    }\n  } else if ($json.response) {\n    llmOutput = $json.response;\n  } else if ($json.message) {\n    llmOutput = $json.message.content || $json.message.text || '';\n  } else if (typeof $json === 'string') {\n    llmOutput = $json;\n  } else {\n    // Try to find any text field\n    llmOutput = JSON.stringify($json);\n  }\n  \n  if (!llmOutput || llmOutput.trim() === '') {\n    return {\n      json: {\n        ...originalData,\n        analysis: {\n          meeting_type: 'unknown',\n          confidence: 'low',\n          needs_manual_review: true,\n          error: 'Empty LLM response'\n        },\n        needs_update: false,\n        needs_move: false\n      }\n    };\n  }\n  \n  // Clean up response - remove markdown code blocks if present\n  let cleaned = llmOutput.trim();\n  cleaned = cleaned.replace(/^```json\\n?/i, '');\n  cleaned = cleaned.replace(/^```\\n?/i, '');\n  cleaned = cleaned.replace(/\\n?```$/i, '');\n  cleaned = cleaned.trim();\n  \n  // Try to extract JSON from response\n  let analysis;\n  try {\n    analysis = JSON.parse(cleaned);\n  } catch (e) {\n    // Try to find JSON object in the text\n    const jsonMatch = cleaned.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      try {\n        analysis = JSON.parse(jsonMatch[0]);\n      } catch (e2) {\n        return {\n          json: {\n            ...originalData,\n            analysis: {\n              meeting_type: 'unknown',\n              confidence: 'low',\n              needs_manual_review: true,\n              error: 'Failed to parse LLM JSON response',\n              raw_output: cleaned.substring(0, 500)\n            },\n            needs_update: false,\n            needs_move: false\n          }\n        };\n      }\n    } else {\n      return {\n        json: {\n          ...originalData,\n          analysis: {\n            meeting_type: 'unknown',\n            confidence: 'low',\n            needs_manual_review: true,\n            error: 'No JSON found in LLM response',\n            raw_output: cleaned.substring(0, 500)\n          },\n          needs_update: false,\n          needs_move: false\n        }\n      };\n    }\n  }\n  \n  // Validate required fields\n  if (!analysis.meeting_type) {\n    analysis.meeting_type = 'unknown';\n  }\n  if (!analysis.confidence) {\n    analysis.confidence = 'low';\n  }\n  if (analysis.needs_manual_review === undefined) {\n    analysis.needs_manual_review = analysis.confidence === 'low' || !analysis.correct_folder;\n  }\n  \n  // Ensure new optional fields have defaults if missing\n  if (!analysis.confidence_reason) {\n    analysis.confidence_reason = '';\n  }\n  if (!analysis.review_reason) {\n    analysis.review_reason = '';\n  }\n  if (!analysis.date_detected) {\n    analysis.date_detected = '';\n  }\n  if (!analysis.partner) {\n    analysis.partner = '';\n  }\n  if (!analysis.team) {\n    analysis.team = '';\n  }\n  \n  // Calculate if file needs moving\n  const vaultRoot = '/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1';\n  // Safely get current relative path with null checks\n  let currentRelative = originalData.relative_path || '';\n  if (!currentRelative && originalData.filepath && typeof originalData.filepath === 'string') {\n    currentRelative = originalData.filepath.replace(vaultRoot + '/', '');\n  }\n  const targetRelative = analysis.correct_folder || '';\n  \n  // Normalize paths for comparison (remove trailing slashes)\n  const normalizedCurrent = (currentRelative || '').replace(/\\/$/, '');\n  const normalizedTarget = (targetRelative || '').replace(/\\/$/, '');\n  const currentDir = normalizedCurrent ? normalizedCurrent.substring(0, normalizedCurrent.lastIndexOf('/')) : '';\n  \n  // Only calculate move if we have both current and target paths\n  const needsMove = targetRelative && \n                    targetRelative.trim() !== '' && \n                    normalizedCurrent && \n                    normalizedCurrent.trim() !== '' &&\n                    currentDir !== normalizedTarget &&\n                    !normalizedCurrent.startsWith(normalizedTarget + '/');\n  \n  // Ensure we have at least minimal originalData structure\n  const resultData = {\n    filepath: originalData.filepath || '',\n    filename: originalData.filename || '',\n    current_folder: originalData.current_folder || '',\n    relative_path: originalData.relative_path || currentRelative || '',\n    frontmatter: originalData.frontmatter || {},\n    content: originalData.content || '',\n    has_frontmatter: originalData.has_frontmatter || false,\n    ...originalData\n  };\n  \n  return {\n    json: {\n      ...resultData,\n      analysis,\n      needs_update: !analysis.needs_manual_review,\n      needs_move: needsMove\n    }\n  };\n} catch (error) {\n  // Fallback: try to get original data from input or use current json\n  let fallbackData = {};\n  try {\n    if ($input && $input.item && $input.item.json) {\n      fallbackData = $input.item.json;\n    } else if ($json) {\n      fallbackData = $json;\n    }\n  } catch (e) {\n    // If all else fails, use empty object\n    fallbackData = $json || {};\n  }\n  return {\n    json: {\n      ...fallbackData,\n      analysis: {\n        meeting_type: 'unknown',\n        confidence: 'low',\n        needs_manual_review: true,\n        error: error.message\n      },\n      needs_update: false,\n      needs_move: false\n    }\n  };\n}\n"
      },
      "id": "a3919faf-417d-452b-bed3-538afe6f60da",
      "name": "Parse LLM Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -8848,
        -1168
      ]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "llm-prompt",
              "name": "prompt",
              "value": "=Analyze this Obsidian meeting note and extract metadata. Be confident - only mark for manual review if truly uncertain.\n\n=== FILE INFORMATION ===\nFile Path: {{ $json.relative_path || $json.filepath }}\nExisting Frontmatter:\n{{ JSON.stringify($json.frontmatter, null, 2) }}\n\n=== NOTE CONTENT ===\n{{ $json.content }}\n\n=== TASK ===\nClassify the meeting type, extract metadata, and determine the correct folder location.\n\n=== OUTPUT FORMAT ===\nReturn ONLY valid JSON (no markdown, no code blocks, no explanation). Use this exact structure:\n\n{\n  \"meeting_type\": \"1on1|customer|partner|internal|unknown\",\n  \"person\": \"Full Name\" or empty string,\n  \"client\": \"Company Name\" or empty string,\n  \"partner\": \"Partner Name\" or empty string,\n  \"team\": \"Team Name\" or empty string,\n  \"location\": \"Boston|Denver|Milwaukee|Indianapolis|Cincinnati|Phoenix|Louisville\" or empty string,\n  \"attendees\": \"Name1, Name2, Name3\" or empty string,\n  \"date_detected\": \"YYYY-MM-DD\" or empty string,\n  \"summary\": \"1-2 sentence summary of the meeting\",\n  \"action_items\": [\"item1\", \"item2\"] or empty array,\n  \"key_topics\": [\"topic1\", \"topic2\"] or empty array,\n  \"correct_folder\": \"Work/Areas/One on One Meetings/{person}/\" or \"Work/Projects/Active Deals/Clients/{location}/{client}/\" or \"Work/Projects/Active Deals/Partners/{partner}/\" or \"Work/Areas/Expedient Teams/{team}/\" or empty string,\n  \"confidence\": \"high|medium|low\",\n  \"confidence_reason\": \"Brief explanation of confidence level\",\n  \"needs_manual_review\": false,\n  \"review_reason\": \"\" or explanation if review needed\n}\n\n=== CLASSIFICATION RULES ===\n1. 1on1: Meeting with one person from Expedient team (see list below)\n2. Customer: Meeting with external client company\n3. Partner: Meeting with partner/vendor company\n4. Internal: Team meeting with multiple Expedient people\n5. Unknown: Cannot determine (be conservative - if unsure, use this)\n\n=== FOLDER ROUTING ===\n- 1on1 → Work/Areas/One on One Meetings/{person}/\n- Customer → Work/Projects/Active Deals/Clients/{location}/{client}/\n- Partner → Work/Projects/Active Deals/Partners/{partner}/\n- Internal → Work/Areas/Expedient Teams/{team}/\n- Unknown → needs_manual_review: true\n\n=== EXPEDIENT TEAM MEMBERS ===\nManager: Rob McCafferty\nDirect Reports: David Determan, Patrick Rosenberger, Keith Cadieux\nTeam: Ben Gallo, Brian Lacombe, Chad St. Thomas, David Saliba, Jacob Figueroa, Jason Molitor, Aaron Littlejohn, Jeff Fertitta, Anthony Jackman, Duane Weber, Bob Carter, Kate Rance\n\n=== KNOWN CLIENTS BY LOCATION ===\nBoston: AAA, Bluestone Bank, Chase Corp, City Brewing, DFCU, Element Fleet Management, Fiduciary Trust, Flower City, GW&K, Hawkes Learning, Logitech, Medwiz, Metropolitan Opera, Phia, St. Mary's Bank, Tricon, U Mass Med, United Way CT\nDenver: AGC Bio, City and County of Denver, DMSi, Pursuit Collective\nMilwaukee: Arhaus, Aspirus, Badger Color, BDO, Duly Healthcare, Falcon Plastics, ITASKA, Medline, Messer Cutting, The Mutual Group\nIndianapolis: Aces Power, Byrider, FCFCU, Ford Meter Box, Graham Packaging, Heartland Dental, Indiana Interactive, Ivy Tech, KELMAR, Republic Airways, Rural King\nCincinnati: MCC Label, US Urology\nPhoenix: Brinks Home Security, City of Avondale, Conagra Brands, Moxa, New England Health Plan, PacketWatch, Sonora Quest, Test Equity, Thryv, Tractor Supply\nLouisville: Lifespring\n\n=== CONFIDENCE GUIDELINES ===\n- HIGH: Clear meeting type, identifiable people/companies, obvious location\n- MEDIUM: Most info present but some ambiguity\n- LOW: Missing key information or unclear classification\n\n=== IMPORTANT ===\n- Extract information from the CONTENT, not just frontmatter\n- If content is empty or very short, set needs_manual_review: true\n- Be confident when information is clear\n- Only use \"unknown\" if truly cannot determine\n\nReturn ONLY the JSON object, nothing else.",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "7e2e56ff-cf44-46c2-b072-2b6d767d481a",
      "name": "Build LLM Prompt",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [
        -9664,
        -1168
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "try {\n  const vaultRoot = '/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1';\n  // Get vaultPath from input chain (from Find All MD Files node)\n  const vaultPath = $input.item.json.vaultPath || $json.vaultPath || '';\n  // Construct absolute filepath\n  const filepath = vaultPath ? `${vaultRoot}/${vaultPath}` : '';\n  const relativePath = vaultPath || '';\n  \n  // Handle different response formats from Obsidian API\n  // API might return: plain text, { content: \"...\" }, or { data: \"...\" }\n  let content = '';\n  \n  // Debug: Log what we're receiving\n  const receivedData = $json;\n  const receivedType = typeof receivedData;\n  const receivedKeys = receivedType === 'object' && receivedData !== null ? Object.keys(receivedData) : [];\n  \n  if (typeof $json === 'string') {\n    // Plain text response\n    content = $json;\n  } else if ($json && typeof $json === 'object') {\n    // Try content field first (most common)\n    if ($json.content && typeof $json.content === 'string') {\n      content = $json.content;\n    } else if ($json.data && typeof $json.data === 'string') {\n      content = $json.data;\n    } else if ($json.body && typeof $json.body === 'string') {\n      content = $json.body;\n    } else if ($json.text && typeof $json.text === 'string') {\n      content = $json.text;\n    } else if (Object.keys($json).length === 0) {\n      // Empty object - file might be empty\n      content = '';\n    } else {\n      // If it's an object but no recognized field, try to extract any string value\n      const stringValues = Object.values($json).filter(v => typeof v === 'string');\n      if (stringValues.length > 0) {\n        content = stringValues[0];\n      }\n    }\n  } else if ($json === null || $json === undefined) {\n    content = '';\n  } else {\n    // Fallback: convert to string\n    content = String($json || '');\n  }\n  \n  if (!content && !$json.error) {\n    // Debug info to help diagnose the issue\n    const debugInfo = {\n      receivedType: receivedType,\n      receivedKeys: receivedKeys,\n      receivedDataPreview: typeof receivedData === 'object' && receivedData !== null ? JSON.stringify(receivedData).substring(0, 200) : String(receivedData || '').substring(0, 200),\n      vaultPath: vaultPath\n    };\n    return {\n      json: {\n        filepath,\n        filename: vaultPath ? vaultPath.split('/').pop() : '',\n        current_folder: vaultPath ? vaultPath.substring(0, vaultPath.lastIndexOf('/')) : '',\n        relative_path: relativePath,\n        frontmatter: {},\n        content: '',\n        has_frontmatter: false,\n        error: 'No content returned from API',\n        debug: debugInfo\n      }\n    };\n  }\n  \n  if ($json.error) {\n    return {\n      json: {\n        filepath,\n        filename: vaultPath ? vaultPath.split('/').pop() : '',\n        current_folder: vaultPath ? vaultPath.substring(0, vaultPath.lastIndexOf('/')) : '',\n        relative_path: relativePath,\n        frontmatter: {},\n        content: '',\n        has_frontmatter: false,\n        error: $json.error.message || 'API error'\n      }\n    };\n  }\n  \n  // Extract frontmatter\n  const fmMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);\n  let frontmatter = {};\n  if (fmMatch) {\n    const fmText = fmMatch[1];\n    fmText.split('\\n').forEach(line => {\n      const trimmed = line.trim();\n      if (trimmed && trimmed.includes(':')) {\n        const [key, ...valueParts] = trimmed.split(':');\n        if (key && valueParts.length) {\n          const value = valueParts.join(':').trim();\n          // Handle quoted values\n          frontmatter[key.trim()] = value.replace(/^[\"']|[\"']$/g, '');\n        }\n      }\n    });\n  }\n  \n  // SKIP LOGIC: If file is already processed, skip it\n  if (frontmatter.status === 'processed' && !frontmatter.needs_manual_review) {\n    return {\n      json: {\n        filepath,\n        filename: vaultPath ? vaultPath.split('/').pop() : '',\n        current_folder: vaultPath ? vaultPath.substring(0, vaultPath.lastIndexOf('/')) : '',\n        relative_path: relativePath,\n        frontmatter,\n        content,\n        has_frontmatter: !!fmMatch,\n        skip: true\n      }\n    };\n  }\n  \n  return {\n    json: {\n      filepath,\n      filename: vaultPath ? vaultPath.split('/').pop() : '',\n      current_folder: vaultPath ? vaultPath.substring(0, vaultPath.lastIndexOf('/')) : '',\n      relative_path: relativePath,\n      frontmatter,\n      content,\n      has_frontmatter: !!fmMatch\n    }\n  };\n} catch (error) {\n  const vaultPath = $input.item.json.vaultPath || '';\n  const vaultRoot = '/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1';\n  const filepath = vaultPath ? `${vaultRoot}/${vaultPath}` : '';\n  return {\n    json: {\n      filepath,\n      filename: vaultPath ? vaultPath.split('/').pop() : '',\n      current_folder: vaultPath ? vaultPath.substring(0, vaultPath.lastIndexOf('/')) : '',\n      relative_path: vaultPath || '',\n      frontmatter: {},\n      content: '',\n      has_frontmatter: false,\n      error: error.message\n    }\n  };\n}"
      },
      "id": "5252bb8f-7765-435f-968f-0af8a29be43f",
      "name": "Parse Frontmatter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -9856,
        -1168
      ]
    },
    {
      "parameters": {
        "url": "=http://100.111.39.118:27123/vault/{{ encodeURIComponent($json.vaultPath || $json.relative_path || '') }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBearerAuth",
        "options": {}
      },
      "id": "ae7b9d0d-9f3c-4ef5-af49-be934dee3946",
      "name": "Read File Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        -10064,
        -1168
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "GLdl8kauGGZ3sdXZ",
          "name": "Header Auth account"
        },
        "httpBearerAuth": {
          "id": "0e6NCchfeK4TA18n",
          "name": "Obsidian Local REST API"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "const baseUrl = 'http://100.111.39.118:27123';\nconst authHeader = 'Bearer 4931ee13bc3472b907f251ce39d7b4229a4f7fc360c0ab8f52213329671a7b12';\n\nfunction encodePathPreservingSlashes(p) {\n  return p\n    .split('/')\n    .filter(Boolean)\n    .map(encodeURIComponent)\n    .join('/');\n}\n\nasync function listDirectory(dirPath) {\n  const encoded = encodePathPreservingSlashes(dirPath);\n  const url = `${baseUrl}/vault/${encoded ? `${encoded}/` : ''}`;\n\n  const response = await this.helpers.httpRequest({\n    method: 'GET',\n    url,\n    headers: {\n      Authorization: authHeader,\n    },\n    json: true,\n  });\n\n  return response?.files ?? [];\n}\n\nasync function findMarkdownFiles(startDir) {\n  const results = [];\n  const stack = [startDir];\n\n  while (stack.length) {\n    const dir = stack.pop();\n    const items = await listDirectory.call(this, dir);\n\n    for (const item of items) {\n      const isDirectory = item.endsWith('/');\n      const name = isDirectory ? item.slice(0, -1) : item;\n      const vaultPath = dir ? `${dir}/${name}` : name;\n\n      if (isDirectory) {\n        stack.push(vaultPath);\n        continue;\n      }\n\n      if (!name.endsWith('.md')) continue;\n      if (name === 'Dashboard.md') continue;\n      if (name.startsWith('Janitor-Log-')) continue;\n\n      results.push(vaultPath);\n    }\n  }\n\n  return results;\n}\n\nconst files = await findMarkdownFiles.call(this, 'Work');\n\n// Limit to 10 files for testing\nconst limitedFiles = files.slice(0, 3);\n\nif (limitedFiles.length === 0) {\n  return [{ json: { vaultPath: '', skip: true } }];\n}\n\nreturn limitedFiles.map(vaultPath => ({\n  json: {\n    vaultPath,\n    skip: false,\n  }\n}));\n"
      },
      "id": "07131c5a-fd3e-434a-b383-8adb1a4dfbfb",
      "name": "Find All MD Files",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -10320,
        -1168
      ]
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 2 * * *"
            }
          ]
        }
      },
      "id": "db8720cf-bc78-4af8-b09c-c7e644476628",
      "name": "Nightly Cron (2am)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [
        -10656,
        -1088
      ]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "vault-janitor",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "23607a6c-0e4a-4924-a218-3c30fe3fe778",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -10656,
        -1248
      ],
      "webhookId": "vault-janitor"
    }
  ],
  "pinData": {},
  "connections": {
    "Message a model": {
      "main": [
        [
          {
            "node": "Parse LLM Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Log File": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Summary Log": {
      "main": [
        [
          {
            "node": "Write Log File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge All Results": {
      "main": [
        [
          {
            "node": "Build Summary Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Review Tag": {
      "main": [
        [
          {
            "node": "Merge All Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tag for Manual Review": {
      "main": [
        [
          {
            "node": "Write Review Tag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old File": {
      "main": [
        [
          {
            "node": "Merge All Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write File to New Location": {
      "main": [
        [
          {
            "node": "Delete Old File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare File Move": {
      "main": [
        [
          {
            "node": "Write File to New Location",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Target Folder": {
      "main": [
        [
          {
            "node": "Prepare File Move",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Move?": {
      "main": [
        [
          {
            "node": "Create Target Folder",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge All Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Updated Content": {
      "main": [
        [
          {
            "node": "Needs Move?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Frontmatter": {
      "main": [
        [
          {
            "node": "Write Updated Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Manual Review?": {
      "main": [
        [
          {
            "node": "Update Frontmatter",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Tag for Manual Review",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse LLM Response": {
      "main": [
        [
          {
            "node": "Needs Manual Review?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build LLM Prompt": {
      "main": [
        [
          {
            "node": "Message a model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Frontmatter": {
      "main": [
        [
          {
            "node": "Build LLM Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read File Content": {
      "main": [
        [
          {
            "node": "Parse Frontmatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find All MD Files": {
      "main": [
        [
          {
            "node": "Read File Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Nightly Cron (2am)": {
      "main": [
        [
          {
            "node": "Find All MD Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Find All MD Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "8767e311-1759-4405-81b5-367f337a52d7",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "c5e1547f5523d07350ad127eb528b0babf5905357fceb6236c1dac12d13b637a"
  },
  "id": "SczZkACtnYLRtxP0",
  "tags": []
}