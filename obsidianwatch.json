{
  "name": "Vault Janitor",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "vault-janitor",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "vault-janitor"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 2 * * *"
            }
          ]
        }
      },
      "id": "cron-trigger",
      "name": "Nightly Cron (2am)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [250, 450]
    },
    {
      "parameters": {
        "jsCode": "const baseUrl = 'http://100.111.39.118:27123';\nconst authHeader = 'Bearer 4931ee13bc3472b907f251ce39d7b4229a4f7fc360c0ab8f52213329671a7b12';\nconst vaultRoot = '/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1';\n\nasync function listDirectory(path) {\n  const encodedPath = encodeURIComponent(path);\n  const url = `${baseUrl}/vault/${encodedPath}`;\n  \n  try {\n    const response = await fetch(url, {\n      headers: {\n        'Authorization': authHeader\n      }\n    });\n    \n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n    \n    const data = await response.json();\n    return data.files || [];\n  } catch (error) {\n    console.error(`Error listing ${path}:`, error.message);\n    return [];\n  }\n}\n\nasync function findMarkdownFiles(dirPath, fileList = []) {\n  try {\n    const items = await listDirectory(dirPath);\n    \n    for (const item of items) {\n      const isDirectory = item.endsWith('/');\n      const itemName = isDirectory ? item.slice(0, -1) : item;\n      const fullPath = dirPath ? `${dirPath}/${itemName}` : itemName;\n      \n      if (isDirectory) {\n        // Recursively search subdirectories\n        await findMarkdownFiles(fullPath, fileList);\n      } else if (itemName.endsWith('.md')) {\n        // Exclude Dashboard.md and Janitor-Log-*.md\n        if (itemName !== 'Dashboard.md' && !itemName.startsWith('Janitor-Log-')) {\n          const absolutePath = `${vaultRoot}/${fullPath}`;\n          fileList.push(absolutePath);\n        }\n      }\n    }\n  } catch (error) {\n    console.error(`Error processing ${dirPath}:`, error.message);\n  }\n  \n  return fileList;\n}\n\n// Start recursive search from Work directory\nconst files = await findMarkdownFiles('Work');\n\nif (files.length === 0) {\n  return [{ json: { filepath: '', filename: '', skip: true } }];\n}\n\nreturn files.map(filepath => ({\n  json: {\n    filepath: filepath,\n    skip: false\n  }\n}));"
      },
      "id": "find-files",
      "name": "Find All MD Files",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 375]
    },
    {
      "parameters": {
        "url": "=http://100.111.39.118:27123/vault/{{ encodeURIComponent($json.filepath.replace('/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1/', '')) }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "id": "read-file",
      "name": "Read File Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [850, 375],
      "credentials": {
        "httpHeaderAuth": {
          "id": "obsidian-api",
          "name": "Obsidian Local REST API"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "try {\n  const content = $json.content || '';\n  const filepath = $input.item.json.filepath;\n  const vaultRoot = '/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1';\n  \n  if (!$json.content && !$json.error) {\n    return {\n      json: {\n        filepath,\n        filename: filepath.split('/').pop(),\n        current_folder: filepath.substring(0, filepath.lastIndexOf('/')),\n        frontmatter: {},\n        content: '',\n        has_frontmatter: false,\n        error: 'No content returned from API'\n      }\n    };\n  }\n  \n  if ($json.error) {\n    return {\n      json: {\n        filepath,\n        filename: filepath.split('/').pop(),\n        current_folder: filepath.substring(0, filepath.lastIndexOf('/')),\n        frontmatter: {},\n        content: '',\n        has_frontmatter: false,\n        error: $json.error.message || 'API error'\n      }\n    };\n  }\n  \n  // Extract frontmatter\n  const fmMatch = content.match(/^---\\n([\\s\\S]*?)\\n---/);\n  let frontmatter = {};\n  if (fmMatch) {\n    const fmText = fmMatch[1];\n    fmText.split('\\n').forEach(line => {\n      const trimmed = line.trim();\n      if (trimmed && trimmed.includes(':')) {\n        const [key, ...valueParts] = trimmed.split(':');\n        if (key && valueParts.length) {\n          const value = valueParts.join(':').trim();\n          // Handle quoted values\n          frontmatter[key.trim()] = value.replace(/^[\"']|[\"']$/g, '');\n        }\n      }\n    });\n  }\n  \n  // Calculate relative path for comparison\n  const relativePath = filepath.replace(vaultRoot + '/', '');\n  \n  return {\n    json: {\n      filepath,\n      filename: filepath.split('/').pop(),\n      current_folder: filepath.substring(0, filepath.lastIndexOf('/')),\n      relative_path: relativePath,\n      frontmatter,\n      content,\n      has_frontmatter: !!fmMatch\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      filepath: $input.item.json.filepath || '',\n      filename: ($input.item.json.filepath || '').split('/').pop(),\n      current_folder: ($input.item.json.filepath || '').substring(0, ($input.item.json.filepath || '').lastIndexOf('/')),\n      frontmatter: {},\n      content: '',\n      has_frontmatter: false,\n      error: error.message\n    }\n  };\n}"
      },
      "id": "parse-content",
      "name": "Parse Frontmatter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 375]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "llm-prompt",
              "name": "prompt",
              "value": "=You are analyzing an Obsidian note to extract metadata and determine its correct location.\n\nCURRENT FILE PATH: {{ $json.relative_path || $json.filepath }}\nCURRENT FRONTMATTER: {{ JSON.stringify($json.frontmatter, null, 2) }}\nCONTENT:\n{{ $json.content }}\n\nExtract and return ONLY a JSON object with this structure:\n{\n  \"meeting_type\": \"1on1|customer|partner|internal|unknown\",\n  \"person\": \"Full Name (for 1on1s only)\",\n  \"client\": \"Company Name (for customer meetings)\",\n  \"location\": \"Boston|Denver|Milwaukee|Indianapolis|Cincinnati|Phoenix|Louisville\",\n  \"attendees\": \"Name1, Name2, Name3\",\n  \"summary\": \"Brief summary of meeting\",\n  \"action_items\": [\"Action 1\", \"Action 2\"],\n  \"key_topics\": [\"Topic 1\", \"Topic 2\"],\n  \"correct_folder\": \"Work/Areas/One on One Meetings/{person}/\" or \"Work/Projects/Active Deals/Clients/{location}/{client}/\",\n  \"confidence\": \"high|medium|low\",\n  \"needs_manual_review\": true|false\n}\n\nFOLDER ROUTING RULES:\n- 1on1 meetings → Work/Areas/One on One Meetings/{person}/\n- Customer meetings → Work/Projects/Active Deals/Clients/{location}/{client}/\n- Partner meetings → Work/Projects/Active Deals/Partners/{partner}/\n- Internal team meetings → Work/Areas/Expedient Teams/{team}/\n- Unknown/low confidence → needs_manual_review: true\n\nATTENDEE CONTEXT (people at Expedient):\n- Rob McCafferty (manager)\n- David Determan, Patrick Rosenberger, Keith Cadieux (direct reports)\n- Ben Gallo, Brian Lacombe, Chad St. Thomas, David Saliba, Jacob Figueroa, Jason Molitor, Aaron Littlejohn\n- Jeff Fertitta, Anthony Jackman, Duane Weber, Bob Carter, Kate Rance\n\nKNOWN CLIENTS BY LOCATION:\nBoston: AAA, Bluestone Bank, Chase Corp, City Brewing, DFCU, Element Fleet Management, Fiduciary Trust, Flower City, GW&K, Hawkes Learning, Logitech, Medwiz, Metropolitan Opera, Phia, St. Mary's Bank, Tricon, U Mass Med, United Way CT\n\nDenver: AGC Bio, City and County of Denver, DMSi, Pursuit Collective\n\nMilwaukee: Arhaus, Aspirus, Badger Color, BDO, Duly Healthcare, Falcon Plastics, ITASKA, Medline, Messer Cutting, The Mutual Group\n\nIndianapolis: Aces Power, Byrider, FCFCU, Ford Meter Box, Graham Packaging, Heartland Dental, Indiana Interactive, Ivy Tech, KELMAR, Republic Airways, Rural King\n\nCincinnati: MCC Label, US Urology\n\nPhoenix: Brinks Home Security, City of Avondale, Conagra Brands, Moxa, New England Health Plan, PacketWatch, Sonora Quest, Test Equity, Thryv, Tractor Supply\n\nLouisville: Lifespring\n\nIf you see these names, it's likely an internal or 1on1 meeting.\n\nReturn ONLY the JSON object, no markdown formatting, no explanation.",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "build-prompt",
      "name": "Build LLM Prompt",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [1250, 375]
    },
    {
      "parameters": {
        "operation": "message",
        "model": "claude-sonnet-4-20250514",
        "messages": {
          "values": [
            {
              "role": "user",
              "content": "={{ $json.prompt }}"
            }
          ]
        },
        "options": {
          "maxTokens": 2000,
          "temperature": 0
        }
      },
      "id": "llm-analysis",
      "name": "LLM Analysis",
      "type": "n8n-nodes-langchain.anthropic",
      "typeVersion": 1,
      "position": [1450, 375],
      "continueOnFail": true,
      "credentials": {
        "anthropicApi": {
          "id": "anthropic-api",
          "name": "Anthropic API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "try {\n  const originalData = $input.first().json;\n  \n  // Handle Anthropic node response format\n  let llmOutput = '';\n  \n  // n8n Anthropic node typically returns: { output: \"...\" } or { text: \"...\" } or direct text\n  if ($json.output) {\n    llmOutput = $json.output;\n  } else if ($json.text) {\n    llmOutput = $json.text;\n  } else if ($json.content) {\n    // Handle array format: { content: [{ type: \"text\", text: \"...\" }] }\n    if (Array.isArray($json.content)) {\n      const textContent = $json.content.find(c => c.type === 'text');\n      if (textContent && textContent.text) {\n        llmOutput = textContent.text;\n      }\n    } else if (typeof $json.content === 'string') {\n      llmOutput = $json.content;\n    }\n  } else if ($json.response) {\n    llmOutput = $json.response;\n  } else if ($json.message) {\n    llmOutput = $json.message.content || $json.message.text || '';\n  } else if (typeof $json === 'string') {\n    llmOutput = $json;\n  } else {\n    // Try to find any text field\n    llmOutput = JSON.stringify($json);\n  }\n  \n  if (!llmOutput || llmOutput.trim() === '') {\n    return {\n      json: {\n        ...originalData,\n        analysis: {\n          meeting_type: 'unknown',\n          confidence: 'low',\n          needs_manual_review: true,\n          error: 'Empty LLM response'\n        },\n        needs_update: false,\n        needs_move: false\n      }\n    };\n  }\n  \n  // Clean up response - remove markdown code blocks if present\n  let cleaned = llmOutput.trim();\n  cleaned = cleaned.replace(/^```json\\n?/i, '');\n  cleaned = cleaned.replace(/^```\\n?/i, '');\n  cleaned = cleaned.replace(/\\n?```$/i, '');\n  cleaned = cleaned.trim();\n  \n  // Try to extract JSON from response\n  let analysis;\n  try {\n    analysis = JSON.parse(cleaned);\n  } catch (e) {\n    // Try to find JSON object in the text\n    const jsonMatch = cleaned.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      try {\n        analysis = JSON.parse(jsonMatch[0]);\n      } catch (e2) {\n        return {\n          json: {\n            ...originalData,\n            analysis: {\n              meeting_type: 'unknown',\n              confidence: 'low',\n              needs_manual_review: true,\n              error: 'Failed to parse LLM JSON response',\n              raw_output: cleaned.substring(0, 500)\n            },\n            needs_update: false,\n            needs_move: false\n          }\n        };\n      }\n    } else {\n      return {\n        json: {\n          ...originalData,\n          analysis: {\n            meeting_type: 'unknown',\n            confidence: 'low',\n            needs_manual_review: true,\n            error: 'No JSON found in LLM response',\n            raw_output: cleaned.substring(0, 500)\n          },\n          needs_update: false,\n          needs_move: false\n        }\n      };\n    }\n  }\n  \n  // Validate required fields\n  if (!analysis.meeting_type) {\n    analysis.meeting_type = 'unknown';\n  }\n  if (!analysis.confidence) {\n    analysis.confidence = 'low';\n  }\n  if (analysis.needs_manual_review === undefined) {\n    analysis.needs_manual_review = analysis.confidence === 'low' || !analysis.correct_folder;\n  }\n  \n  // Calculate if file needs moving\n  const vaultRoot = '/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1';\n  const currentRelative = originalData.relative_path || originalData.filepath.replace(vaultRoot + '/', '');\n  const targetRelative = analysis.correct_folder || '';\n  \n  // Normalize paths for comparison (remove trailing slashes)\n  const normalizedCurrent = currentRelative.replace(/\\/$/, '');\n  const normalizedTarget = targetRelative.replace(/\\/$/, '');\n  const currentDir = normalizedCurrent.substring(0, normalizedCurrent.lastIndexOf('/'));\n  \n  const needsMove = targetRelative && \n                    targetRelative.trim() !== '' && \n                    currentDir !== normalizedTarget &&\n                    !normalizedCurrent.startsWith(normalizedTarget + '/');\n  \n  return {\n    json: {\n      ...originalData,\n      analysis,\n      needs_update: !analysis.needs_manual_review,\n      needs_move: needsMove\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...$input.first().json,\n      analysis: {\n        meeting_type: 'unknown',\n        confidence: 'low',\n        needs_manual_review: true,\n        error: error.message\n      },\n      needs_update: false,\n      needs_move: false\n    }\n  };\n}"
      },
      "id": "parse-llm",
      "name": "Parse LLM Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 375]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "needs-review-1",
              "leftValue": "={{ $json.analysis && $json.analysis.needs_manual_review }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            },
            {
              "id": "needs-review-2",
              "leftValue": "={{ $json.analysis && $json.analysis.confidence }}",
              "rightValue": "low",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "needs-review-3",
              "leftValue": "={{ $json.analysis && $json.analysis.error }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "id": "check-confidence",
      "name": "Needs Manual Review?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1850, 375]
    },
    {
      "parameters": {
        "jsCode": "try {\n  const data = $json;\n  const fm = data.frontmatter || {};\n  const analysis = data.analysis || {};\n  \n  // Build updated frontmatter\n  const updated = {\n    date: fm.date || new Date().toISOString().split('T')[0],\n    type: 'meeting',\n    meeting_type: analysis.meeting_type || 'unknown',\n    person: analysis.person || '',\n    client: analysis.client || '',\n    location: analysis.location || '',\n    partner: analysis.partner || '',\n    team: analysis.team || '',\n    attendees: analysis.attendees || '',\n    summary: analysis.summary || '',\n    project: fm.project || 'unclassified',\n    status: 'processed'\n  };\n  \n  // Remove empty fields\n  Object.keys(updated).forEach(key => {\n    if (updated[key] === '') {\n      delete updated[key];\n    }\n  });\n  \n  // Build new frontmatter block\n  const fmLines = Object.entries(updated)\n    .map(([k, v]) => {\n      // Escape colons in values if needed\n      const value = typeof v === 'string' && v.includes(':') ? `\"${v}\"` : v;\n      return `${k}: ${value}`;\n    })\n    .join('\\n');\n  \n  const newFrontmatter = `---\\n${fmLines}\\n---`;\n  \n  // Replace old frontmatter in content or add if missing\n  let newContent = data.content || '';\n  if (newContent.match(/^---\\n[\\s\\S]*?\\n---/)) {\n    newContent = newContent.replace(/^---[\\s\\S]*?---/, newFrontmatter);\n  } else {\n    newContent = newFrontmatter + '\\n\\n' + newContent;\n  }\n  \n  // Add action items if not present\n  if (analysis.action_items && Array.isArray(analysis.action_items) && analysis.action_items.length > 0) {\n    if (!newContent.includes('## Action Items')) {\n      const items = analysis.action_items.map(item => `- [ ] ${item}`).join('\\n');\n      newContent += `\\n\\n## Action Items\\n${items}`;\n    }\n  }\n  \n  // Add key topics if not present\n  if (analysis.key_topics && Array.isArray(analysis.key_topics) && analysis.key_topics.length > 0) {\n    if (!newContent.includes('## Key Topics')) {\n      const topics = analysis.key_topics.map(t => `- ${t}`).join('\\n');\n      newContent += `\\n\\n## Key Topics\\n${topics}`;\n    }\n  }\n  \n  return {\n    json: {\n      ...data,\n      updated_content: newContent\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...$json,\n      updated_content: $json.content || '',\n      error: error.message\n    }\n  };\n}"
      },
      "id": "update-frontmatter",
      "name": "Update Frontmatter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2050, 275]
    },
    {
      "parameters": {
        "url": "=http://100.111.39.118:27123/vault/{{ encodeURIComponent($json.relative_path || $json.filepath.replace('/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1/', '')) }}",
        "method": "PUT",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "contentType": "json",
        "bodyParameters": {
          "parameters": [
            {
              "name": "content",
              "value": "={{ $json.updated_content }}"
            }
          ]
        },
        "options": {}
      },
      "id": "write-updated",
      "name": "Write Updated Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2250, 275],
      "credentials": {
        "httpHeaderAuth": {
          "id": "obsidian-api",
          "name": "Obsidian Local REST API"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "needs-move",
              "leftValue": "={{ $json.needs_move }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-move",
      "name": "Needs Move?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2450, 275]
    },
    {
      "parameters": {
        "jsCode": "// Folders will be created automatically when files are written to them\n// This is a no-op node to maintain workflow structure\nreturn $input.all();"
      },
      "id": "create-folder",
      "name": "Create Target Folder",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2650, 175]
    },
    {
      "parameters": {
        "jsCode": "// Prepare file move operation\n// The actual move will be done by writing to new location and deleting old\nconst data = $json;\nconst vaultRoot = '/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1';\nconst oldRelativePath = data.relative_path || data.filepath.replace(vaultRoot + '/', '');\nconst newFolder = data.analysis.correct_folder.replace(/\\/$/, '');\nconst newRelativePath = `${newFolder}/${data.filename}`;\n\nreturn {\n  json: {\n    ...data,\n    old_relative_path: oldRelativePath,\n    new_relative_path: newRelativePath,\n    move_content: data.updated_content || data.content\n  }\n};"
      },
      "id": "move-file-prep",
      "name": "Prepare File Move",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2850, 175]
    },
    {
      "parameters": {
        "url": "=http://100.111.39.118:27123/vault/{{ encodeURIComponent($json.new_relative_path) }}",
        "method": "PUT",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "contentType": "json",
        "bodyParameters": {
          "parameters": [
            {
              "name": "content",
              "value": "={{ $json.move_content }}"
            }
          ]
        },
        "options": {}
      },
      "id": "move-file-write",
      "name": "Write File to New Location",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [3050, 175],
      "credentials": {
        "httpHeaderAuth": {
          "id": "obsidian-api",
          "name": "Obsidian Local REST API"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "url": "=http://100.111.39.118:27123/vault/{{ encodeURIComponent($json.old_relative_path) }}",
        "method": "DELETE",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "id": "move-file",
      "name": "Delete Old File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [3250, 175],
      "credentials": {
        "httpHeaderAuth": {
          "id": "obsidian-api",
          "name": "Obsidian Local REST API"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "try {\n  const data = $json;\n  const fm = data.frontmatter || {};\n  \n  // Build frontmatter with needs-manual-review status\n  const updated = {\n    ...fm,\n    date: fm.date || new Date().toISOString().split('T')[0],\n    type: 'meeting',\n    status: 'needs-manual-review'\n  };\n  \n  // Add or update tags\n  const existingTags = fm.tags || '';\n  const needsReviewTag = '#needs-manual-review';\n  let tags = existingTags;\n  if (!tags.includes(needsReviewTag)) {\n    tags = tags ? `${tags} ${needsReviewTag}` : needsReviewTag;\n  }\n  updated.tags = tags;\n  \n  // Build new frontmatter block\n  const fmLines = Object.entries(updated)\n    .map(([k, v]) => {\n      const value = typeof v === 'string' && v.includes(':') ? `\"${v}\"` : v;\n      return `${k}: ${value}`;\n    })\n    .join('\\n');\n  \n  const newFrontmatter = `---\\n${fmLines}\\n---`;\n  \n  // Replace old frontmatter or add if missing\n  let newContent = data.content || '';\n  if (newContent.match(/^---\\n[\\s\\S]*?\\n---/)) {\n    newContent = newContent.replace(/^---[\\s\\S]*?---/, newFrontmatter);\n  } else {\n    newContent = newFrontmatter + '\\n\\n' + newContent;\n  }\n  \n  return {\n    json: {\n      ...data,\n      updated_content: newContent\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      ...$json,\n      updated_content: $json.content || '',\n      error: error.message\n    }\n  };\n}"
      },
      "id": "tag-manual-review",
      "name": "Tag for Manual Review",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2050, 475]
    },
    {
      "parameters": {
        "url": "=http://100.111.39.118:27123/vault/{{ encodeURIComponent($json.relative_path || $json.filepath.replace('/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1/', '')) }}",
        "method": "PUT",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "contentType": "json",
        "bodyParameters": {
          "parameters": [
            {
              "name": "content",
              "value": "={{ $json.updated_content }}"
            }
          ]
        },
        "options": {}
      },
      "id": "write-review-tag",
      "name": "Write Review Tag",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2250, 475],
      "credentials": {
        "httpHeaderAuth": {
          "id": "obsidian-api",
          "name": "Obsidian Local REST API"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "append"
      },
      "id": "merge-results",
      "name": "Merge All Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [3050, 375]
    },
    {
      "parameters": {
        "jsCode": "try {\n  const items = $input.all();\n  const timestamp = new Date().toISOString();\n  const date = timestamp.split('T')[0];\n  \n  // Filter out skipped items\n  const processedItems = items.filter(i => !i.json.skip);\n  \n  const stats = {\n    total: processedItems.length,\n    updated: processedItems.filter(i => i.json.needs_update && !i.json.error).length,\n    moved: processedItems.filter(i => i.json.needs_move && !i.json.error).length,\n    needs_review: processedItems.filter(i => i.json.analysis?.needs_manual_review || i.json.error).length,\n    errors: processedItems.filter(i => i.json.error).length\n  };\n  \n  const reviewFiles = processedItems\n    .filter(i => i.json.analysis?.needs_manual_review || i.json.error)\n    .map(i => ({\n      filename: i.json.filename,\n      confidence: i.json.analysis?.confidence || 'unknown',\n      error: i.json.error\n    }));\n  \n  const movedFiles = processedItems\n    .filter(i => i.json.needs_move && !i.json.error)\n    .map(i => ({\n      filename: i.json.filename,\n      from: i.json.current_folder,\n      to: i.json.analysis?.correct_folder || 'unknown'\n    }));\n  \n  const errorFiles = processedItems\n    .filter(i => i.json.error)\n    .map(i => ({\n      filename: i.json.filename,\n      error: i.json.error\n    }));\n  \n  let log = `# Vault Janitor Log - ${timestamp}\\n\\n## Summary\\n`;\n  log += `- **Total files processed:** ${stats.total}\\n`;\n  log += `- **Metadata updated:** ${stats.updated}\\n`;\n  log += `- **Files moved:** ${stats.moved}\\n`;\n  log += `- **Needs manual review:** ${stats.needs_review}\\n`;\n  if (stats.errors > 0) {\n    log += `- **Errors:** ${stats.errors}\\n`;\n  }\n  \n  log += `\\n## Files Needing Review\\n`;\n  if (reviewFiles.length > 0) {\n    reviewFiles.forEach(file => {\n      log += `- [[${file.filename}]] - ${file.confidence} confidence`;\n      if (file.error) {\n        log += ` (Error: ${file.error})`;\n      }\n      log += '\\n';\n    });\n  } else {\n    log += `None\\n`;\n  }\n  \n  log += `\\n## Files Moved\\n`;\n  if (movedFiles.length > 0) {\n    movedFiles.forEach(file => {\n      log += `- [[${file.filename}]] → ${file.to}\\n`;\n    });\n  } else {\n    log += `None\\n`;\n  }\n  \n  if (errorFiles.length > 0) {\n    log += `\\n## Errors\\n`;\n    errorFiles.forEach(file => {\n      log += `- [[${file.filename}]] - ${file.error}\\n`;\n    });\n  }\n  \n  return {\n    json: {\n      log_content: log,\n      log_path: `/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1/Work/00-Inbox/Janitor-Log-${date}.md`,\n      stats: stats\n    }\n  };\n} catch (error) {\n  return {\n    json: {\n      log_content: `# Vault Janitor Log - ${new Date().toISOString()}\\n\\nError generating log: ${error.message}\\n`,\n      log_path: `/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1/Work/00-Inbox/Janitor-Log-${new Date().toISOString().split('T')[0]}.md`,\n      stats: { total: 0, updated: 0, moved: 0, needs_review: 0, errors: 1 }\n    }\n  };\n}"
      },
      "id": "build-log",
      "name": "Build Summary Log",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3250, 375]
    },
    {
      "parameters": {
        "url": "=http://100.111.39.118:27123/vault/{{ encodeURIComponent($json.log_path.replace('/Users/joshdavis/Library/Mobile Documents/iCloud~md~obsidian/Documents/dvsobs1/', '')) }}",
        "method": "PUT",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "contentType": "json",
        "bodyParameters": {
          "parameters": [
            {
              "name": "content",
              "value": "={{ $json.log_content }}"
            }
          ]
        },
        "options": {}
      },
      "id": "write-log",
      "name": "Write Log File",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [3450, 375],
      "credentials": {
        "httpHeaderAuth": {
          "id": "obsidian-api",
          "name": "Obsidian Local REST API"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { success: true, message: 'Vault janitor completed', log_path: $json.log_path, stats: $json.stats } }}"
      },
      "id": "webhook-response",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [3650, 300]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Find All MD Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Nightly Cron (2am)": {
      "main": [
        [
          {
            "node": "Find All MD Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find All MD Files": {
      "main": [
        [
          {
            "node": "Read File Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read File Content": {
      "main": [
        [
          {
            "node": "Parse Frontmatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Frontmatter": {
      "main": [
        [
          {
            "node": "Build LLM Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build LLM Prompt": {
      "main": [
        [
          {
            "node": "LLM Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Analysis": {
      "main": [
        [
          {
            "node": "Parse LLM Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse LLM Response": {
      "main": [
        [
          {
            "node": "Needs Manual Review?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Manual Review?": {
      "main": [
        [
          {
            "node": "Update Frontmatter",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Tag for Manual Review",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Frontmatter": {
      "main": [
        [
          {
            "node": "Write Updated Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Updated Content": {
      "main": [
        [
          {
            "node": "Needs Move?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Needs Move?": {
      "main": [
        [
          {
            "node": "Create Target Folder",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge All Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Target Folder": {
      "main": [
        [
          {
            "node": "Prepare File Move",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare File Move": {
      "main": [
        [
          {
            "node": "Write File to New Location",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write File to New Location": {
      "main": [
        [
          {
            "node": "Delete Old File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old File": {
      "main": [
        [
          {
            "node": "Merge All Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tag for Manual Review": {
      "main": [
        [
          {
            "node": "Write Review Tag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Review Tag": {
      "main": [
        [
          {
            "node": "Merge All Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge All Results": {
      "main": [
        [
          {
            "node": "Build Summary Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Summary Log": {
      "main": [
        [
          {
            "node": "Write Log File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Log File": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  }
}
